import { O as RootContent, P as Nodes } from './types/theme-css-variables.mjs';
export { C as CssVariablesThemeOptions, S as ShorthandsBundle, a as addClassToHast, b as applyColorReplacements, Q as codeToHast, T as codeToHtml, U as codeToTokens, V as codeToTokensBase, W as codeToTokensWithThemes, c as createCssVariablesTheme, d as createHighlighterCore, e as createHighlighterCoreSync, K as createJavaScriptRegexEngine, L as createOnigurumaEngine, f as createPositionConverter, g as createShikiInternal, h as createShikiInternalSync, i as createSingletonShorthands, j as createWasmOnigEngine, k as createdBundledHighlighter, M as defaultJavaScriptRegexConstructor, l as enableDeprecationWarnings, m as getHighlighterCore, n as getShikiInternal, o as getSingletonHighlighterCore, p as getTokenStyleObject, q as isNoneTheme, r as isPlainLang, s as isSpecialLang, t as isSpecialTheme, N as loadWasm, u as makeSingletonHighlighter, v as makeSingletonHighlighterCore, w as normalizeGetter, x as normalizeTheme, y as resolveColorReplacements, z as splitLines, A as splitToken, B as splitTokens, D as stringifyTokenStyle, E as toArray, F as tokenizeAnsiWithTheme, G as tokenizeWithTheme, H as tokensToHast, I as transformerDecorations, J as warnDeprecated } from './types/theme-css-variables.mjs';
export * from '@shikijs/types';
import '@shikijs/engine-javascript';

declare const enum FontStyle {
    NotSet = -1,
    None = 0,
    Italic = 1,
    Bold = 2,
    Underline = 4,
    Strikethrough = 8
}

type EncodedTokenAttributes = number;
declare class EncodedTokenMetadata {
    static toBinaryStr(encodedTokenAttributes: EncodedTokenAttributes): string;
    static print(encodedTokenAttributes: EncodedTokenAttributes): void;
    static getLanguageId(encodedTokenAttributes: EncodedTokenAttributes): number;
    static getTokenType(encodedTokenAttributes: EncodedTokenAttributes): StandardTokenType;
    static containsBalancedBrackets(encodedTokenAttributes: EncodedTokenAttributes): boolean;
    static getFontStyle(encodedTokenAttributes: EncodedTokenAttributes): number;
    static getForeground(encodedTokenAttributes: EncodedTokenAttributes): number;
    static getBackground(encodedTokenAttributes: EncodedTokenAttributes): number;
    /**
     * Updates the fields in `metadata`.
     * A value of `0`, `NotSet` or `null` indicates that the corresponding field should be left as is.
     */
    static set(encodedTokenAttributes: EncodedTokenAttributes, languageId: number | 0, tokenType: OptionalStandardTokenType | OptionalStandardTokenType.NotSet, containsBalancedBrackets: boolean | null, fontStyle: FontStyle | FontStyle.NotSet, foreground: number | 0, background: number | 0): number;
}
declare const enum StandardTokenType {
    Other = 0,
    Comment = 1,
    String = 2,
    RegEx = 3
}
declare const enum OptionalStandardTokenType {
    Other = 0,
    Comment = 1,
    String = 2,
    RegEx = 3,
    NotSet = 8
}

type FormatSmartOptions = {
    /**
     * Prefer named character references (`&amp;`) where possible.
     */
    useNamedReferences?: boolean;
    /**
     * Prefer the shortest possible reference, if that results in less bytes.
     * **Note**: `useNamedReferences` can be omitted when using `useShortestReferences`.
     */
    useShortestReferences?: boolean;
    /**
     * Whether to omit semicolons when possible.
     * **Note**: This creates what HTML calls ‚Äúparse errors‚Äù but is otherwise still valid HTML ‚Äî don‚Äôt use this except when building a minifier.
     * Omitting semicolons is possible for certain named and numeric references in some cases.
     */
    omitOptionalSemicolons?: boolean;
    /**
     * Create character references which don‚Äôt fail in attributes.
     * **Note**: `attribute` only applies when operating dangerously with
     * `omitOptionalSemicolons: true`.
     */
    attribute?: boolean;
};

type CoreOptions = {
    /**
     * Whether to only escape the given subset of characters.
     */
    subset?: ReadonlyArray<string>;
    /**
     * Whether to only escape possibly dangerous characters.
     * Those characters are `"`, `&`, `'`, `<`, `>`, and `` ` ``.
     */
    escapeOnly?: boolean;
};

type Options$2 = CoreOptions & FormatSmartOptions;

type Options$1 = Options$2;

/**
 * Serialize hast as HTML.
 *
 * @param {Array<RootContent> | Nodes} tree
 *   Tree to serialize.
 * @param {Options | null | undefined} [options]
 *   Configuration (optional).
 * @returns {string}
 *   Serialized HTML.
 */
declare function toHtml(tree: Array<RootContent> | Nodes, options?: Options | null | undefined): string;
type CharacterReferences = Omit<Options$1, "attribute" | "escapeOnly" | "subset">;
/**
 * Configuration.
 */
type Options = {
    /**
     * Do not encode some characters which cause XSS vulnerabilities in older
     * browsers (default: `false`).
     *
     * > ‚ö†Ô∏è **Danger**: only set this if you completely trust the content.
     */
    allowDangerousCharacters?: boolean | null | undefined;
    /**
     * Allow `raw` nodes and insert them as raw HTML (default: `false`).
     *
     * When `false`, `Raw` nodes are encoded.
     *
     * > ‚ö†Ô∏è **Danger**: only set this if you completely trust the content.
     */
    allowDangerousHtml?: boolean | null | undefined;
    /**
     * Do not encode characters which cause parse errors (even though they work),
     * to save bytes (default: `false`).
     *
     * Not used in the SVG space.
     *
     * > üëâ **Note**: intentionally creates parse errors in markup (how parse
     * > errors are handled is well defined, so this works but isn‚Äôt pretty).
     */
    allowParseErrors?: boolean | null | undefined;
    /**
     * Use ‚Äúbogus comments‚Äù instead of comments to save byes: `<?charlie>`
     * instead of `<!--charlie-->` (default: `false`).
     *
     * > üëâ **Note**: intentionally creates parse errors in markup (how parse
     * > errors are handled is well defined, so this works but isn‚Äôt pretty).
     */
    bogusComments?: boolean | null | undefined;
    /**
     * Configure how to serialize character references (optional).
     */
    characterReferences?: CharacterReferences | null | undefined;
    /**
     * Close SVG elements without any content with slash (`/`) on the opening tag
     * instead of an end tag: `<circle />` instead of `<circle></circle>`
     * (default: `false`).
     *
     * See `tightSelfClosing` to control whether a space is used before the
     * slash.
     *
     * Not used in the HTML space.
     */
    closeEmptyElements?: boolean | null | undefined;
    /**
     * Close self-closing nodes with an extra slash (`/`): `<img />` instead of
     * `<img>` (default: `false`).
     *
     * See `tightSelfClosing` to control whether a space is used before the
     * slash.
     *
     * Not used in the SVG space.
     */
    closeSelfClosing?: boolean | null | undefined;
    /**
     * Collapse empty attributes: get `class` instead of `class=""` (default:
     * `false`).
     *
     * Not used in the SVG space.
     *
     * > üëâ **Note**: boolean attributes (such as `hidden`) are always collapsed.
     */
    collapseEmptyAttributes?: boolean | null | undefined;
    /**
     * Omit optional opening and closing tags (default: `false`).
     *
     * For example, in `<ol><li>one</li><li>two</li></ol>`, both `</li>` closing
     * tags can be omitted.
     * The first because it‚Äôs followed by another `li`, the last because it‚Äôs
     * followed by nothing.
     *
     * Not used in the SVG space.
     */
    omitOptionalTags?: boolean | null | undefined;
    /**
     * Leave attributes unquoted if that results in less bytes (default: `false`).
     *
     * Not used in the SVG space.
     */
    preferUnquoted?: boolean | null | undefined;
    /**
     * Use the other quote if that results in less bytes (default: `false`).
     */
    quoteSmart?: boolean | null | undefined;
    /**
     * Preferred quote to use (default: `'"'`).
     */
    quote?: Quote | null | undefined;
    /**
     * When an `<svg>` element is found in the HTML space, this package already
     * automatically switches to and from the SVG space when entering and exiting
     * it (default: `'html'`).
     *
     * > üëâ **Note**: hast is not XML.
     * > It supports SVG as embedded in HTML.
     * > It does not support the features available in XML.
     * > Passing SVG might break but fragments of modern SVG should be fine.
     * > Use [`xast`][xast] if you need to support SVG as XML.
     */
    space?: Space | null | undefined;
    /**
     * Join attributes together, without whitespace, if possible: get
     * `class="a b"title="c d"` instead of `class="a b" title="c d"` to save
     * bytes (default: `false`).
     *
     * Not used in the SVG space.
     *
     * > üëâ **Note**: intentionally creates parse errors in markup (how parse
     * > errors are handled is well defined, so this works but isn‚Äôt pretty).
     */
    tightAttributes?: boolean | null | undefined;
    /**
     * Join known comma-separated attribute values with just a comma (`,`),
     * instead of padding them on the right as well (`,‚ê†`, where `‚ê†` represents a
     * space) (default: `false`).
     */
    tightCommaSeparatedLists?: boolean | null | undefined;
    /**
     * Drop unneeded spaces in doctypes: `<!doctypehtml>` instead of
     * `<!doctype html>` to save bytes (default: `false`).
     *
     * > üëâ **Note**: intentionally creates parse errors in markup (how parse
     * > errors are handled is well defined, so this works but isn‚Äôt pretty).
     */
    tightDoctype?: boolean | null | undefined;
    /**
     * Do not use an extra space when closing self-closing elements: `<img/>`
     * instead of `<img />` (default: `false`).
     *
     * > üëâ **Note**: only used if `closeSelfClosing: true` or
     * > `closeEmptyElements: true`.
     */
    tightSelfClosing?: boolean | null | undefined;
    /**
     * Use a `<!DOCTYPE‚Ä¶` instead of `<!doctype‚Ä¶` (default: `false`).
     *
     * Useless except for XHTML.
     */
    upperDoctype?: boolean | null | undefined;
    /**
     * Tag names of elements to serialize without closing tag (default: `html-void-elements`).
     *
     * Not used in the SVG space.
     *
     * > üëâ **Note**: It‚Äôs highly unlikely that you want to pass this, because
     * > hast is not for XML, and HTML will not add more void elements.
     */
    voids?: ReadonlyArray<string> | null | undefined;
};
/**
 * HTML quotes for attribute values.
 */
type Quote = "\"" | "'";
/**
 * Namespace.
 */
type Space = "html" | "svg";

export { FontStyle, EncodedTokenMetadata as StackElementMetadata, toHtml as hastToHtml };
